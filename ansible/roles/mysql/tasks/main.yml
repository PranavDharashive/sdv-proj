---
- name: Create MySQL data directory
  file:
    path: /mnt/mysql-db-data/
    state: directory
    mode: '0777'

- name: Create local storage class
  kubernetes.core.k8s:
    state: present
    src: "{{ role_path }}/files/local-storage-class.yml"
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"

- name: Get Kubernetes node name
  command: kubectl get nodes -o jsonpath='{.items[0].metadata.name}'
  register: k8s_node_name
  changed_when: false
  environment:
    KUBECONFIG: "/root/.kube/config"

- name: Debug - Kubernetes node name
  debug:
    var: k8s_node_name.stdout

- name: Debug - Full kubectl get nodes output
  command: kubectl get nodes
  register: kubectl_get_nodes_full_output
  changed_when: false
  failed_when: false
  environment:
    KUBECONFIG: "/root/.kube/config"

- name: Debug - Print full kubectl get nodes output
  debug:
    var: kubectl_get_nodes_full_output.stdout_lines

- name: Debug - Kubernetes node name used for PV
  debug:
    var: k8s_node_name.stdout

- name: Get existing MySQL PersistentVolume info
  kubernetes.core.k8s_info:
    kind: PersistentVolume
    name: mysql-pv
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"
  register: existing_mysql_pv_info
  ignore_errors: yes

- name: Debug - Existing MySQL PV info (full variable)
  debug:
    var: existing_mysql_pv_info

- name: Debug - Type of existing_mysql_pv_info.resources
  debug:
    msg: "Type of existing_mysql_pv_info.resources: {{ existing_mysql_pv_info.resources | type_debug }}"

- name: Debug - Content of existing_mysql_pv_info.resources
  debug:
    var: existing_mysql_pv_info.resources

- name: Set fact for normalized existing_mysql_pv_resources
  set_fact:
    normalized_existing_mysql_pv_resources: "{{ existing_mysql_pv_info.resources | default([]) }}"

- name: Render MySQL PersistentVolume template
  template:
    src: "{{ role_path }}/templates/mysql-pv.yml.j2"
    dest: "/tmp/mysql-pv.yml"
  when: normalized_existing_mysql_pv_resources | length == 0

- name: Deploy MySQL PersistentVolume
  kubernetes.core.k8s:
    state: present
    src: "/tmp/mysql-pv.yml"
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"
  register: mysql_pv_deploy_result
  ignore_errors: yes
  when: normalized_existing_mysql_pv_resources | length == 0

- name: Fail if MySQL PV deployment failed due to immutable field
  fail:
    msg: |
      Failed to deploy MySQL PersistentVolume 'mysql-pv'.
      Error: {{ mysql_pv_deploy_result.msg }}
      This usually means the PV already exists with an incorrect nodeAffinity, which is immutable.
      If this PV contains important data, please back it up manually.
      Then, delete the existing PV and PVC (kubectl delete pv mysql-pv pvc mysql-pvc -n sdv) and re-run the playbook.
  when: mysql_pv_deploy_result is defined and mysql_pv_deploy_result.failed is defined and mysql_pv_deploy_result.failed and 'field is immutable' in mysql_pv_deploy_result.msg


- name: Deploy MySQL PersistentVolumeClaim
  kubernetes.core.k8s:
    state: present
    src: "{{ role_path }}/files/mysql-pvc.yml"
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"

- name: Wait for MySQL PVC to be bound
  kubernetes.core.k8s_info:
    kind: PersistentVolumeClaim
    name: mysql-pvc
    namespace: sdv
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"
  register: mysql_pvc_info

- name: Debug - MySQL PVC info after wait
  debug:
    var: mysql_pvc_info

- name: Wait for Kubernetes API server to be ready
  uri:
    url: "https://{{ kube_api_ip }}:6443/livez?verbose"
    validate_certs: no
  register: api_livez
  until: >
    api_livez.status == 200 and
    '[+]poststarthook/start-kube-apiserver-admission-initializer' in api_livez.content and
    '[+]poststarthook/generic-apiserver-start-informers' in api_livez.content
  retries: 10
  delay: 15
  ignore_errors: yes

- name: Render MySQL deployment template
  template:
    src: "{{ role_path }}/templates/mysql-deployment.yml.j2"
    dest: "/tmp/mysql-deployment.yml"

- name: Deploy MySQL
  kubernetes.core.k8s:
    state: present
    src: "/tmp/mysql-deployment.yml"
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"

- name: Debug - Get MySQL PV info
  command: kubectl get pv mysql-pv -o json
  register: mysql_pv_info
  changed_when: false
  failed_when: false
  environment:
    KUBECONFIG: "{{ ansible_user_dir }}/.kube/config"

- name: Debug - Print MySQL PV info
  debug:
    var: mysql_pv_info.stdout

- name: Debug - Get MySQL PVC info
  command: kubectl get pvc mysql-pvc -n sdv -o json
  register: mysql_pvc_info
  changed_when: false
  failed_when: false
  environment:
    KUBECONFIG: "{{ ansible_user_dir }}/.kube/config"

- name: Debug - Print MySQL PVC info
  debug:
    var: mysql_pvc_info.stdout

- name: Debug - Get MySQL deployment info
  command: kubectl get deployment mysql-deployment -n sdv -o json
  register: mysql_deployment_info
  changed_when: false
  failed_when: false
  environment:
    KUBECONFIG: "{{ ansible_user_dir }}/.kube/config"

- name: Debug - Print MySQL deployment info
  debug:
    var: mysql_deployment_info.stdout

- name: Wait for MySQL deployment to be ready
  kubernetes.core.k8s_info:
    kind: Deployment
    name: mysql-deployment
    namespace: sdv
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"

- name: Get MySQL pods
  kubernetes.core.k8s_info:
    kind: Pod
    namespace: sdv
    label_selectors:
      - app=mysql
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"
  register: mysql_pods

- name: Debug - MySQL pods info (before fail check)
  debug:
    var: mysql_pods

- name: Pause for a few seconds before checking MySQL pod status
  pause:
    seconds: 5

- name: Fail if MySQL pods are not running
  fail:
    msg: "MySQL pods are not running"
  when: mysql_pods.resources | length == 0 or mysql_pods.resources[0].status.phase != 'Running' or not mysql_pods.resources[0].status.containerStatuses[0].ready

- name: Create sdv_data database and user
  shell: |
    kubectl exec -n sdv {{ item.metadata.name }} -- \
    mysql -h '127.0.0.1' -P '3306' -u root -p'{{ mysql_root_password }}' -e "\
      CREATE DATABASE IF NOT EXISTS sdv_data;\
      CREATE USER IF NOT EXISTS 'sdvuser'@'%' IDENTIFIED BY 'abcd1234';\
      GRANT ALL PRIVILEGES ON *.* TO 'sdvuser'@'%' WITH GRANT OPTION;\
      FLUSH PRIVILEGES;"
  loop: "{{ mysql_pods.resources }}"
  vars:
    mysql_root_password: "admin"
  become: true
  become_user: root
  environment:
    KUBECONFIG: "/root/.kube/config"
