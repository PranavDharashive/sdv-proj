---
- name: Create MySQL data directory
  file:
    path: /mnt/mysql-db-data/
    state: directory
    mode: '0777'

- name: Create local storage class
  kubernetes.core.k8s:
    state: present
    src: "{{ role_path }}/files/local-storage-class.yml"
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"

- name: Get Kubernetes node name
  command: kubectl get nodes -o jsonpath='{.items[0].metadata.name}'
  register: k8s_node_name
  changed_when: false
  environment:
    KUBECONFIG: "/root/.kube/config"

- name: Debug - Kubernetes node name
  debug:
    var: k8s_node_name.stdout

- name: Debug - Full kubectl get nodes output
  command: kubectl get nodes
  register: kubectl_get_nodes_full_output
  changed_when: false
  failed_when: false
  environment:
    KUBECONFIG: "/root/.kube/config"

- name: Debug - Print full kubectl get nodes output
  debug:
    var: kubectl_get_nodes_full_output.stdout_lines

- name: Debug - Kubernetes node name used for PV
  debug:
    var: k8s_node_name.stdout

- name: Get existing MySQL PersistentVolume info
  kubernetes.core.k8s_info:
    kind: PersistentVolume
    name: mysql-pv
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"
  register: existing_mysql_pv_info
  ignore_errors: yes

- name: Debug - Existing MySQL PV info
  debug:
    var: existing_mysql_pv_info

- name: Render MySQL PersistentVolume template
  template:
    src: "{{ role_path }}/templates/mysql-pv.yml.j2"
    dest: "/tmp/mysql-pv.yml"
  when: existing_mysql_pv_info.resources | length == 0 or 
        (existing_mysql_pv_info.resources | length > 0 and 
         (existing_mysql_pv_info.resources[0].spec.nodeAffinity is not defined or 
          existing_mysql_pv_info.resources[0].spec.nodeAffinity.required.nodeSelectorTerms[0].matchExpressions[0].values[0] != k8s_node_name.stdout))

- name: Deploy MySQL PersistentVolume
  kubernetes.core.k8s:
    state: present
    src: "/tmp/mysql-pv.yml"
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"
  when: existing_mysql_pv_info.resources | length == 0 or 
        (existing_mysql_pv_info.resources | length > 0 and 
         (existing_mysql_pv_info.resources[0].spec.nodeAffinity is not defined or 
          existing_mysql_pv_info.resources[0].spec.nodeAffinity.required.nodeSelectorTerms[0].matchExpressions[0].values[0] != k8s_node_name.stdout))

- name: Fail if existing MySQL PV has incorrect nodeAffinity
  fail:
    msg: |
      Existing MySQL PersistentVolume 'mysql-pv' has an incorrect nodeAffinity.
      Current: {{ existing_mysql_pv_info.resources[0].spec.nodeAffinity.required.nodeSelectorTerms[0].matchExpressions[0].values[0] }}
      Expected: {{ k8s_node_name.stdout }}
      If this PV contains important data, please back it up manually.
      Then, delete the existing PV and PVC (kubectl delete pv mysql-pv pvc mysql-pvc -n sdv) and re-run the playbook.
  when: existing_mysql_pv_info.resources | length > 0 and 
        (existing_mysql_pv_info.resources[0].spec.nodeAffinity is not defined or 
         existing_mysql_pv_info.resources[0].spec.nodeAffinity.required.nodeSelectorTerms[0].matchExpressions[0].values[0] != k8s_node_name.stdout)


- name: Deploy MySQL PersistentVolumeClaim
  kubernetes.core.k8s:
    state: present
    src: "{{ role_path }}/files/mysql-pvc.yml"
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"

- name: Wait for MySQL PVC to be bound
  kubernetes.core.k8s_info:
    kind: PersistentVolumeClaim
    name: mysql-pvc
    namespace: sdv
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"
  register: mysql_pvc_info

- name: Debug - MySQL PVC info after wait
  debug:
    var: mysql_pvc_info

- name: Render MySQL deployment template
  template:
    src: "{{ role_path }}/templates/mysql-deployment.yml.j2"
    dest: "/tmp/mysql-deployment.yml"

- name: Deploy MySQL
  kubernetes.core.k8s:
    state: present
    src: "/tmp/mysql-deployment.yml"
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"

- name: Debug - Get MySQL PV info
  command: kubectl get pv mysql-pv -o json
  register: mysql_pv_info
  changed_when: false
  failed_when: false
  environment:
    KUBECONFIG: "{{ ansible_user_dir }}/.kube/config"

- name: Debug - Print MySQL PV info
  debug:
    var: mysql_pv_info.stdout

- name: Debug - Get MySQL PVC info
  command: kubectl get pvc mysql-pvc -n sdv -o json
  register: mysql_pvc_info
  changed_when: false
  failed_when: false
  environment:
    KUBECONFIG: "{{ ansible_user_dir }}/.kube/config"

- name: Debug - Print MySQL PVC info
  debug:
    var: mysql_pvc_info.stdout

- name: Debug - Get MySQL deployment info
  command: kubectl get deployment mysql-deployment -n sdv -o json
  register: mysql_deployment_info
  changed_when: false
  failed_when: false
  environment:
    KUBECONFIG: "{{ ansible_user_dir }}/.kube/config"

- name: Debug - Print MySQL deployment info
  debug:
    var: mysql_deployment_info.stdout

- name: Wait for MySQL deployment to be ready
  kubernetes.core.k8s_info:
    kind: Deployment
    name: mysql-deployment
    namespace: sdv
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"

- name: Get MySQL pods
  kubernetes.core.k8s_info:
    kind: Pod
    namespace: sdv
    label_selectors:
      - app=mysql
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"
  register: mysql_pods

- name: Fail if MySQL pods are not running
  fail:
    msg: "MySQL pods are not running"
  when: mysql_pods.resources | length == 0 or mysql_pods.resources[0].status.phase != 'Running' or not mysql_pods.resources[0].status.containerStatuses[0].ready

- name: Create sdv_data database and user
  kubernetes.core.k8s_exec:
    namespace: sdv
    pod: "{{ item.metadata.name }}"
    command: ["/bin/sh", "-c", "mysql -u root -p$MYSQL_ROOT_PASSWORD -e \"CREATE DATABASE IF NOT EXISTS sdv_data; CREATE USER IF NOT EXISTS 'sdvuser'@'%' IDENTIFIED BY 'abcd1234'; GRANT ALL PRIVILEGES ON *.* TO 'sdvuser'@'%' WITH GRANT OPTION; FLUSH PRIVILEGES;\""]
    kubeconfig: "{{ ansible_user_dir }}/.kube/config"
  with_items: "{{ mysql_pods.resources }}"
  vars:
    mysql_root_password: "admin"
